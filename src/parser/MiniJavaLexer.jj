options {
    JAVA_UNICODE_ESCAPE = true;
}

PARSER_BEGIN(MiniJavaParser)
package parser;
import syntaxtree.*;
import visitor.*;

public class MiniJavaParser {
    public static void main(String args[]) {
        MiniJavaParser parser;
        ASTPrintVisitor visitor;

        if(args.length == 0) {
            parser = new MiniJavaParser(System.in);
        } else if(args.length == 1) {
            try {
                parser = new MiniJavaParser(new java.io.FileInputStream(args[0]));
            } catch (java.io.FileNotFoundException e) {
                return;
            }
        } else {
            System.out.println("Give no argument to read from stdin, otherwise specify a sinle input file.");
            return;
        }

        try {
            visitor = new ASTPrintVisitor();
            parser.Program();
        } catch (ParseException e) {
            System.out.println(e.toString());
        }
    }
}
PARSER_END(MiniJavaParser)

/* TOKENS */
// Skip whitespace
SKIP :
{ " " | "\t" | "\n" | "\r" | "\f" }

// Comments
SPECIAL_TOKEN:
{
    < SINGLE_LINE_COMMENT: "//" (~["\n","\n"])* ("\n"|"\r"|"\r\n") >
    | < MULTI_LINE_COMMENT: "/*" (["*"])? (~[])* "*/" >
}

// Reserved words
TOKEN :
{
    < CLASS: "class" >
    | < PUBLIC: "public" >
    | < STATIC: "static" >
    | < VOID: "void" >
    | < STRING: "String" >
    | < RETURN: "return" >
    | < INT: "int" >
    | < BOOLEAN: "boolean" >
    | < IF: "if" >
    | < ELSE: "else" >
    | < WHILE: "while" >
    | < PRINT: "System.out.println" >
    | < LENGTH: "length" >
    | < TRUE: "true" >
    | < FALSE: "false" >
    | < THIS: "this" >
    | < NEW: "new" >
}

// Operators
TOKEN :
{
    < AND: "&&" >
    | < LT: "<" >
    | < PLUS: "+" >
    | < MINUS: "-" >
    | < STAR: "*" >
    | < BANG: "!" >
    | < ASSIGN: "=" >
}

// Separators
TOKEN :
{
    < LBRACE: "{" >
    | < RBRACE: "}" >
    | < LPAREN: "(" >
    | < RPAREN: ")" >
    | < LBRACKET: "[" >
    | < RBRACKET: "]" >
    | < SEMICOLON: ";" >
    | < COMMA: "," >
    | < DOT: "." >
}

// TODO main should not be a reserved word!
TOKEN :
{
    < MAIN: "main" >
}

// Lexicals
TOKEN :
{
    < IDENTIFIER: ["a"-"z","A"-"Z","_"] (["a"-"z","A"-"Z","0"-"9","_"])* >
    | < INTEGER_LITERAL: "0"
        | ["1"-"9"] (["0"-"9"])* >
}

/* GRAMMAR */
Program Program() :
{ MainClass mc; ClassDeclList cdl = new ClassDeclList(); ClassDecl cd; }
{
    mc = MainClass() ( cd = ClassDecl() { cdl.addElement(cd); } )*
    <EOF>
    { return new Program(mc, cdl); }
}

// TODO How should s be initialised?
// TODO Handle VarDecl?
MainClass MainClass() :
{ Identifier i1; Identifier i2; StatementList sl = new StatementList(); Statement s = null; }
{
    "class" i1 = Identifier() "{" "public" "static" "void" "main" "(" "String" "[" "]"
    i2 = Identifier() ")" "{" ( LOOKAHEAD(2) VarDecl() )* ( s = Stmt() { sl.addElement(s); } )* "}" "}"
    { return new MainClass(i1, i2, s); }
}

// TODO When is ClassDeclExtends needed?
ClassDecl ClassDecl() :
{
    Identifier i; VarDecl vd; VarDeclList vdl = new VarDeclList(); MethodDecl md;
    MethodDeclList mdl = new MethodDeclList();
}
{
    "class" i = Identifier() "{" ( vd = VarDecl() { vdl.addElement(vd); } )*
    ( md = MethodDecl() { mdl.addElement(md); } )* "}"
    { return new ClassDeclSimple(i, vdl, mdl); }
}

VarDecl VarDecl() :
{ Type t; Identifier i; }
{
    t = Type() i = Identifier() ";"
    { return new VarDecl(t, i); }
}

MethodDecl MethodDecl() :
{
    Type t; Identifier i; FormalList fl = new FormalList(); VarDecl vd; VarDeclList vdl  = new VarDeclList();
    Statement s; StatementList sl = new StatementList(); Exp e;
}
{
    "public" t = Type() i = Identifier() "(" fl = FormalList() ")" "{"
    ( LOOKAHEAD(2) vd = VarDecl() { vdl.addElement(vd); } )*
    ( s = Stmt() { sl.addElement(s); } )* "return" e = Exp() ";" "}"
    { return new MethodDecl(t, i, fl, vdl, sl, e); }
}

// TODO Is this the correct creation of new Formals?
FormalList FormalList() :
{ Formal f; FormalList fl = new FormalList(); Type t; Identifier i; }
{
    (
    t = Type() i = Identifier() { fl.addElement(new Formal(t, i)); }
    ( f = FormalRest() { fl.addElement(f); } )*
    | {}
    )
    { return fl; }
}

// TODO Is this the correct creation of new Formals?
Formal FormalRest() :
{ Type t; Identifier i; }
{
    "," t = Type() i = Identifier()
    { return new Formal(t, i); }
}

Type Type() :
{ Type t; Token tok; }
{
    (
    LOOKAHEAD(2) "int" "[" "]" { t = new IntegerType(); }
    | "boolean" { t = new BooleanType(); }
    | "int" { t = new IntegerType(); }
    | <IDENTIFIER> { t  = null; } // TODO Handle different 'types'
    )
    { return t; }
}

Statement Stmt() :
{}
{
    (
    "{" ( Stmt() )* "}"
    | "if" "(" Exp() ")" Stmt() "else" Stmt()
    | "while" "(" Exp() ")" Stmt()
    | "System.out.println" "(" Exp() ")" ";"
    | LOOKAHEAD(2) <IDENTIFIER> "=" Exp() ";"
    | <IDENTIFIER> "[" Exp() "]" "=" Exp() ";"
    )
    { return new If(null, null, null); } // TODO Test
}

// TODO What expression?
Exp Exp() :
{ Exp e = null; Exp ie; Token i; Identifier id; } // TODO Remove init to null
{
    (
    e = IntegerLiteral() ExpPrim()
    | "true" ExpPrim() { e = new True(); }
    | "false" ExpPrim() { e = new False(); }
    | i = <IDENTIFIER> ExpPrim() { e = new IdentifierExp(i.toString()); } // TODO Shall this be converted here?
    | "this" ExpPrim() { e = new This(); }
    | LOOKAHEAD(2) "new" "int" "[" ie = Exp() "]" ExpPrim() { e = new NewArray(ie); } // TODO ExpPrim?
    | "new" id = Identifier() "(" ")" ExpPrim() { e = new NewObject(id); }
    | "!" ie = Exp() ExpPrim() { e = new Not(ie); } // TODO How should ExpPrim be handled by ie?
    | "(" e = Exp() ")" ExpPrim()
    )
    { return e; }
}

// Eliminate left recursion
// TODO What?
Exp ExpPrim() :
{ Exp e; }
{
    (
    Op() Exp() ExpPrim() // TODO is ExpPrim() needed?
    | "[" Exp() "]" ExpPrim()
    | LOOKAHEAD(2) "." "length" ExpPrim()
    | "." <IDENTIFIER> "(" ExpList() ")" ExpPrim()
    | {}
    )
    { return null; } // TODO Test
}

// TODO What operation?
Exp Op() :
{}
{
    (
    "&&"
    | "<"
    | "+"
    | "-"
    | "*"
    )
    { return null; } // TODO Test
}

ExpList ExpList() :
{ Exp e1; Exp e2; ExpList el = new ExpList(); }
{
    (
    e1 = Exp() { el.addElement(e1); }( e2 = ExpRest() { el.addElement(e2); } )*
    | {}
    )
    { return el; }
}

Exp ExpRest() :
{ Exp e; }
{
    "," e = Exp()
    { return e; }
}

// To be able to extract the identifier value
Identifier Identifier() :
{ Token i; }
{
    i = <IDENTIFIER>
    { return new Identifier(i.toString()); }
}

// To be able to extract the int value
IntegerLiteral IntegerLiteral() :
{ Token il; }
{
    il = <INTEGER_LITERAL>
    { return new IntegerLiteral(Integer.parseInt(il.toString())); }
}
