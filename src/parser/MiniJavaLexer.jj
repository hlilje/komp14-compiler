options {
    JAVA_UNICODE_ESCAPE = true;
}

PARSER_BEGIN(MiniJavaParser)
package parser;
import syntaxtree.*;
import visitor.*;

public class MiniJavaParser {
    public static void main(String args[]) {
        MiniJavaParser parser;
        ASTPrintVisitor visitor;
        Program p;

        if(args.length == 0) {
            parser = new MiniJavaParser(System.in);
        } else if(args.length == 1) {
            try {
                parser = new MiniJavaParser(new java.io.FileInputStream(args[0]));
            } catch (java.io.FileNotFoundException e) {
                return;
            }
        } else {
            System.out.println("Give no argument to read from stdin, otherwise specify a sinle input file.");
            return;
        }

        try {
            p = parser.Program();

            visitor = new ASTPrintVisitor();
            visitor.visit(p);
        } catch (ParseException e) {
            System.out.println(e.toString());
        }
    }
}
PARSER_END(MiniJavaParser)

/* TOKENS */
// Skip whitespace
SKIP :
{ " " | "\t" | "\n" | "\r" | "\f" }

// Comments
SPECIAL_TOKEN:
{
    < SINGLE_LINE_COMMENT: "//" (~["\n","\n"])* ("\n"|"\r"|"\r\n") >
    | < MULTI_LINE_COMMENT: "/*" (["*"])? (~[])* "*/" >
}

// Reserved words
TOKEN :
{
    < CLASS: "class" >
    | < PUBLIC: "public" >
    | < STATIC: "static" >
    | < VOID: "void" >
    | < STRING: "String" >
    | < RETURN: "return" >
    | < INT: "int" >
    | < BOOLEAN: "boolean" >
    | < IF: "if" >
    | < ELSE: "else" >
    | < WHILE: "while" >
    | < PRINT: "System.out.println" >
    | < LENGTH: "length" >
    | < TRUE: "true" >
    | < FALSE: "false" >
    | < THIS: "this" >
    | < NEW: "new" >
}

// Operators
TOKEN :
{
    < AND: "&&" >
    | < LT: "<" >
    | < PLUS: "+" >
    | < MINUS: "-" >
    | < STAR: "*" >
    | < BANG: "!" >
    | < ASSIGN: "=" >
}

// Separators
TOKEN :
{
    < LBRACE: "{" >
    | < RBRACE: "}" >
    | < LPAREN: "(" >
    | < RPAREN: ")" >
    | < LBRACKET: "[" >
    | < RBRACKET: "]" >
    | < SEMICOLON: ";" >
    | < COMMA: "," >
    | < DOT: "." >
}

// Lexicals
TOKEN :
{
    < IDENTIFIER: ["a"-"z","A"-"Z","_"] (["a"-"z","A"-"Z","0"-"9","_"])* >
    | < INTEGER_LITERAL: "0"
        | ["1"-"9"] (["0"-"9"])* >
}

/* GRAMMAR */
Program Program() :
{ MainClass mc; ClassDeclList cdl = new ClassDeclList(); ClassDecl cd; }
{
    mc = MainClass() ( cd = ClassDecl() { cdl.addElement(cd); } )*
    <EOF>
    { return new Program(mc, cdl); }
}

// TODO Handle VarDecl?
MainClass MainClass() :
{ Identifier i1; Identifier i2; StatementList sl = new StatementList(); Statement s = null; } // TODO Remove init to null
{
    // TODO Check that identifier is main later
    "class" i1 = Identifier() "{" "public" "static" "void" <IDENTIFIER> "(" "String" "[" "]"
    i2 = Identifier() ")" "{" ( LOOKAHEAD(2) VarDecl() )* ( s = Stmt() { sl.addElement(s); } )* "}" "}"
    { return new MainClass(i1, i2, s); }
}

// ClassDeclExtends is an extension to the grammar
ClassDecl ClassDecl() :
{
    Identifier i; VarDecl vd; VarDeclList vdl = new VarDeclList(); MethodDecl md;
    MethodDeclList mdl = new MethodDeclList();
}
{
    "class" i = Identifier() "{" ( vd = VarDecl() { vdl.addElement(vd); } )*
    ( md = MethodDecl() { mdl.addElement(md); } )* "}"
    { return new ClassDeclSimple(i, vdl, mdl); }
}

VarDecl VarDecl() :
{ Type t; Identifier i; }
{
    t = Type() i = Identifier() ";"
    { return new VarDecl(t, i); }
}

MethodDecl MethodDecl() :
{
    Type t; Identifier i; FormalList fl = new FormalList(); VarDecl vd; VarDeclList vdl  = new VarDeclList();
    Statement s; StatementList sl = new StatementList(); Exp e;
}
{
    "public" t = Type() i = Identifier() "(" fl = FormalList() ")" "{"
    ( LOOKAHEAD(2) vd = VarDecl() { vdl.addElement(vd); } )*
    ( s = Stmt() { sl.addElement(s); } )* "return" e = Exp() ";" "}"
    { return new MethodDecl(t, i, fl, vdl, sl, e); }
}

// TODO Is this the correct creation of new Formals?
FormalList FormalList() :
{ Formal f; FormalList fl = new FormalList(); Type t; Identifier i; }
{
    (
    t = Type() i = Identifier() { fl.addElement(new Formal(t, i)); }
    ( f = FormalRest() { fl.addElement(f); } )*
    | {}
    )
    { return fl; }
}

// TODO Is this the correct creation of new Formals?
Formal FormalRest() :
{ Type t; Identifier i; }
{
    "," t = Type() i = Identifier()
    { return new Formal(t, i); }
}

Type Type() :
{ Type t; Token tok; }
{
    (
    LOOKAHEAD(2) "int" "[" "]" { t = new IntegerType(); }
    | "boolean" { t = new BooleanType(); }
    | "int" { t = new IntegerType(); }
    | tok = <IDENTIFIER> { t  = new IdentifierType(tok.toString()); } // TODO toString here?
    )
    { return t; }
}

Statement Stmt() :
{
    StatementList sl = new StatementList(); Statement s; Statement s1; Statement s2;
    Exp e1; Exp e2; Identifier i;
}
{
    (
    "{" ( s1 = Stmt() { sl.addElement(s1); } )* "}" { s = new Block(sl); }
    | "if" "(" e1 = Exp() ")" s1 = Stmt() "else" s2 = Stmt() { s = new If(e1, s1, s2); }
    | "while" "(" e1 = Exp() ")" s1 = Stmt() { s = new While(e1, s1); }
    | "System.out.println" "(" e1 = Exp() ")" ";" { s = new Print(e1); }
    | LOOKAHEAD(2) i = Identifier() "=" e1 = Exp() ";" { s = new Assign(i, e1); }
    | i = Identifier() "[" e1 = Exp() "]" "=" e2 = Exp() ";" { s = new ArrayAssign(i, e1, e2); }
    )
    { return s; }
}

Exp Exp() :
{ Exp e; Exp ie; Exp ep; Token i; Identifier id; }
{
    (
    e = IntegerLiteral() ep = ExpPrim(e)
    | "true" { e = new True(); } ep = ExpPrim(e)
    | "false" { e = new False(); } ep = ExpPrim(e)
    | i = <IDENTIFIER> { e = new IdentifierExp(i.toString()); } ep = ExpPrim(e) // TODO Shall this be converted here?
    | "this" { e = new This(); } ep = ExpPrim(e)
    | LOOKAHEAD(2) "new" "int" "[" ie = Exp() "]" { e = new NewArray(ie); } ep = ExpPrim(e)
    | "new" id = Identifier() "(" ")" { e = new NewObject(id); } ep = ExpPrim(e)
    | "!" ie = Exp() { e = new Not(ie); } ep = ExpPrim(e)
    | "(" e = Exp() ")" ep = ExpPrim(e)
    )
    { return ep; }
}

// Eliminate left recursion
// ExpPrim has been removed
Exp ExpPrim(Exp eb) :
{ Exp e; Exp ep; Exp ea; Identifier i; ExpList el;}
{
    (
    ep = Op(eb)
    | "[" ea = Exp() "]" { e = new ArrayLookup(eb, ea); } ep = ExpPrim(e)
    | LOOKAHEAD(2) "." "length" { e = new ArrayLength(eb); } ep = ExpPrim(e)
    | "." i = Identifier() "(" el = ExpList() ")" { e = new Call(eb, i, el); } ep = ExpPrim(e)
    | { ep = eb; } // Else return the other expression
    )
    { return ep; }
}

// Exp moved here to get the right evaluation order
Exp Op(Exp eb) :
{ Exp e; Exp ea; }
{
    (
    "&&" ea = Exp() { e = new And(eb, ea); }
    | "<" ea = Exp() { e = new LessThan(eb, ea); }
    | "+" ea = Exp() { e = new Plus(eb, ea); }
    | "-" ea = Exp() { e = new Minus(eb, ea); }
    | "*" ea = Exp() { e = new Times(eb, ea); }
    )
    { return e; }
}

ExpList ExpList() :
{ Exp e1; Exp e2; ExpList el = new ExpList(); }
{
    (
    e1 = Exp() { el.addElement(e1); }( e2 = ExpRest() { el.addElement(e2); } )*
    | {}
    )
    { return el; }
}

Exp ExpRest() :
{ Exp e; }
{
    "," e = Exp()
    { return e; }
}

// To be able to extract the identifier value
Identifier Identifier() :
{ Token i; }
{
    i = <IDENTIFIER>
    { return new Identifier(i.toString()); }
}

// To be able to extract the int value
IntegerLiteral IntegerLiteral() :
{ Token il; }
{
    il = <INTEGER_LITERAL>
    { return new IntegerLiteral(Integer.parseInt(il.toString())); }
}
