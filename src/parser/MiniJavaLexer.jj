options {
    JAVA_UNICODE_ESCAPE = true;
}

PARSER_BEGIN(MiniJavaParser)
package parser;

import syntaxtree.*;
import visitor.*;

public class MiniJavaParser {
    public MiniJavaParser() {}
}
PARSER_END(MiniJavaParser)

/* TOKENS */
// Skip whitespace
SKIP :
{ " " | "\t" | "\n" | "\r" | "\f" }

// Comments
SPECIAL_TOKEN:
{
    < SINGLE_LINE_COMMENT: "//" (~["\n","\n"])* ("\n"|"\r"|"\r\n") >
    | < MULTI_LINE_COMMENT: "/*" (["*"])? (~[])* "*/" >
}

// Reserved words
TOKEN :
{
    < CLASS: "class" >
    | < PUBLIC: "public" >
    | < STATIC: "static" >
    | < VOID: "void" >
    | < STRING: "String" >
    | < RETURN: "return" >
    | < INT: "int" >
    | < BOOLEAN: "boolean" >
    | < IF: "if" >
    | < ELSE: "else" >
    | < WHILE: "while" >
    | < PRINT: "System.out.println" >
    | < LENGTH: "length" >
    | < TRUE: "true" >
    | < FALSE: "false" >
    | < THIS: "this" >
    | < NEW: "new" >
}

// Operators
TOKEN :
{
    < AND: "&&" >
    | < LT: "<" >
    | < PLUS: "+" >
    | < MINUS: "-" >
    | < STAR: "*" >
    | < BANG: "!" >
    | < ASSIGN: "=" >
    | < LEQ: "<=" > // Extensions follows
    | < GT: ">" >
    | < GEQ: ">=" >
    | < EQ: "==" >
    | < NEQ: "!=" >
    | < OR: "||" > // Separate extension
}

// Separators
TOKEN :
{
    < LBRACE: "{" >
    | < RBRACE: "}" >
    | < LPAREN: "(" >
    | < RPAREN: ")" >
    | < LBRACKET: "[" >
    | < RBRACKET: "]" >
    | < SEMICOLON: ";" >
    | < COMMA: "," >
    | < DOT: "." >
}

// Lexicals
TOKEN :
{
    < IDENTIFIER: ["a"-"z","A"-"Z","_"] (["a"-"z","A"-"Z","0"-"9","_"])* >
    | < INTEGER_LITERAL: "0"
        | ["1"-"9"] (["0"-"9"])* >
}

/* GRAMMAR */
Program Program() :
{ MainClass mc; ClassDeclList cdl = new ClassDeclList(); ClassDecl cd; }
{
    mc = MainClass() ( cd = ClassDecl() { cdl.addElement(cd); } )*
    <EOF>
    { return new Program(mc, cdl); }
}

MainClass MainClass() :
{
    Identifier i1, i2; StatementList sl = new StatementList(); Statement s; // TODO Remove init to null
    VarDeclList vdl = new VarDeclList(); VarDecl vd;
}
{
    // TODO Check that identifier is main later
    "class" i1 = Identifier() "{" "public" "static" "void" <IDENTIFIER> "(" "String" "[" "]"
    i2 = Identifier() ")" "{" ( LOOKAHEAD(2) vd = VarDecl() { vdl.addElement(vd); } )*
    ( s = Stmt() { sl.addElement(s); } )* "}" "}"
    { return new MainClass(i1, i2, sl, vdl); }
}

// ClassDeclExtends is an extension to the grammar
ClassDecl ClassDecl() :
{
    Identifier i; VarDecl vd; VarDeclList vdl = new VarDeclList(); MethodDecl md;
    MethodDeclList mdl = new MethodDeclList();
}
{
    "class" i = Identifier() "{" ( vd = VarDecl() { vdl.addElement(vd); } )*
    ( md = MethodDecl() { mdl.addElement(md); } )* "}"
    { return new ClassDeclSimple(i, vdl, mdl); }
}

VarDecl VarDecl() :
{ Type t; Identifier i; }
{
    t = Type() i = Identifier() ";"
    { return new VarDecl(t, i); }
}

MethodDecl MethodDecl() :
{
    Type t; Identifier i; FormalList fl = new FormalList(); VarDecl vd; VarDeclList vdl  = new VarDeclList();
    Statement s; StatementList sl = new StatementList(); Exp e;
}
{
    "public" t = Type() i = Identifier() "(" fl = FormalList() ")" "{"
    ( LOOKAHEAD(2) vd = VarDecl() { vdl.addElement(vd); } )*
    ( s = Stmt() { sl.addElement(s); } )* "return" e = Exp() ";" "}"
    { return new MethodDecl(t, i, fl, vdl, sl, e); }
}

// TODO Is this the correct creation of new Formals?
FormalList FormalList() :
{ Formal f; FormalList fl = new FormalList(); Type t; Identifier i; }
{
    (
    t = Type() i = Identifier() { fl.addElement(new Formal(t, i)); }
    ( f = FormalRest() { fl.addElement(f); } )*
    | {}
    )
    { return fl; }
}

// TODO Is this the correct creation of new Formals?
Formal FormalRest() :
{ Type t; Identifier i; }
{
    "," t = Type() i = Identifier()
    { return new Formal(t, i); }
}

Type Type() :
{ Type t; Token tok; }
{
    (
    LOOKAHEAD(2) "int" "[" "]" { t = new IntArrayType(); }
    | "boolean" { t = new BooleanType(); }
    | "int" { t = new IntegerType(); }
    | tok = <IDENTIFIER> { t  = new IdentifierType(tok.toString()); } // TODO toString here?
    )
    { return t; }
}

Statement Stmt() :
{
    StatementList sl = new StatementList(); Statement s, s1, s2;
    Exp e1, e2; Identifier i; VarDeclList vdl = new VarDeclList();
    VarDecl vd;
}
{
    (
    "{" (LOOKAHEAD(2) vd = VarDecl() { vdl.addElement(vd); } )*
        ( s1 = Stmt() { sl.addElement(s1); } )* "}" { s = new Block(sl, vdl); }
    | "if" "(" e1 = Exp() ")" s1 = Stmt() "else" s2 = Stmt() { s = new If(e1, s1, s2); }
    | "while" "(" e1 = Exp() ")" s1 = Stmt() { s = new While(e1, s1); }
    | "System.out.println" "(" e1 = Exp() ")" ";" { s = new Print(e1); }
    | LOOKAHEAD(2) i = Identifier() "=" e1 = Exp() ";" { s = new Assign(i, e1); }
    | i = Identifier() "[" e1 = Exp() "]" "=" e2 = Exp() ";" { s = new ArrayAssign(i, e1, e2); }
    )
    { return s; }
}

// Fixes op precedence but not associativity, should be handled in AST
Exp Exp() :
{ Exp e; }
{
    e = Or()
    { return e; }
}

// Binds the loosest
Exp Or() : // TODO
{ Exp e, eb, ea; }
{
    (
    LOOKAHEAD(2) eb = And() ( "||" ea = And() )* { e = new Or(eb, ea); }
    | e = And()
    )
    { return e; }
}

Exp And() : // TODO
{ Exp e, eb, ea; }
{
    (
    LOOKAHEAD(2) eb = LessThan() ( "&&" ea = LessThan() )* { e = new And(eb, ea); }
    | e = LessThan()
    )
    { return e; }
}

Exp LessThan() :
{ Exp e, eb, ea; }
{
    (
    LOOKAHEAD(2) eb = LessThanEquals() "<" ea = LessThanEquals() { e = new LessThan(eb, ea); }
    | e = LessThanEquals()
    )
    { return e; }
}

Exp LessThanEquals() :
{ Exp e, eb, ea; }
{
    (
    LOOKAHEAD(2) eb = GreaterThan() "<=" ea = GreaterThan() { e = new LessThanEquals(eb, ea); }
    | e = GreaterThan()
    )
    { return e; }
}

Exp GreaterThan() :
{ Exp e, eb, ea; }
{
    (
    LOOKAHEAD(2) eb = GreaterThanEquals() ">=" ea = GreaterThanEquals() { e = new GreaterThan(eb, ea); }
    | e = GreaterThanEquals()
    )
    { return e; }
}

Exp GreaterThanEquals() :
{ Exp e, eb, ea; }
{
    (
    LOOKAHEAD(2) eb = Equals() ">" ea = Equals() { e = new GreaterThanEquals(eb, ea); }
    | e = Equals()
    )
    { return e; }
}

Exp Equals() :
{ Exp e, eb, ea; }
{

    (
    LOOKAHEAD(2) eb = EqualsNot() "==" ea = EqualsNot() { e = new Equals(eb, ea); }
    | e = EqualsNot()
    )
    { return e; }
}

Exp EqualsNot() :
{ Exp e, eb, ea; }
{
    (
    LOOKAHEAD(2) eb = Plus() "!=" Plus() { e = new EqualsNot(eb, ea); }
    | e = Plus()
    )
    { return e; }
}

Exp Plus() : // TODO Are plus and minus allowed to be separated?
{ Exp e, eb, ea; }
{
    (
    LOOKAHEAD(2) eb = Minus() ( "+" ea = Minus() )* { e = new Plus(eb, ea); }
    | e = Times()
    )
    { return e; }
}

Exp Minus() : // TODO
{ Exp e, eb, ea; }
{
    (
    LOOKAHEAD(2) eb = Times() ( "-" ea = Times() )* { e = new Minus(eb, ea); }
    | e = Times()
    )
    { return e; }
}

Exp Times() : // TODO
{ Exp e, eb, ea; }
{
    (
    LOOKAHEAD(2) eb = PrefixExp() ( "*" ea = PrefixExp() )* { e = new Times(eb, ea); }
    | e = PrefixExp()
    )
    { return e; }
}

Exp PrefixExp() :
{ Exp e; }
{
    (
    e = Not()
    | e = PostfixExp()
    )
    { return e; }
}

Exp Not() : // TODO Should multiple negations be allowed?
{ Exp e, pe; }
{
    ( "!" )+ pe = PostfixExp() { e = new Not(pe); }
    { return e; }
}

Exp PostfixExp() :
{ Exp e, pe, ie; Identifier i; ExpList el;}
{
    (
    LOOKAHEAD(2) pe = PrimaryExp() ( "[" ie = Exp() "]" { e = new ArrayLookup(pe, ie); }
        | LOOKAHEAD(2) "." i = Identifier() "(" el = ExpList() ")" { e = new Call(pe, i, el); }
        | LOOKAHEAD(2) "." "length" { e = new ArrayLength(pe); } )*
    | e = PrimaryExp()
    )
    { return e; }
}

// Binds the tightest
Exp PrimaryExp() :
{ Exp e, ie, ep; Token i; Identifier id; }
{
    (
    e = IntegerLiteral()
    | "true" { e = new True(); }
    | "false" { e = new False(); }
    | i = <IDENTIFIER> { e = new IdentifierExp(i.toString()); }
    | "this" { e = new This(); }
    | "(" e = Exp() ")"
    | LOOKAHEAD(2) "new" "int" "[" ie = Exp() "]" { e = new NewArray(ie); }
    | LOOKAHEAD(2) "new" id = Identifier() "(" ")" { e = new NewObject(id); }
    )
    { return e; }
}

ExpList ExpList() :
{ Exp e1, e2; ExpList el = new ExpList(); }
{
    (
    e1 = Exp() { el.addElement(e1); }( e2 = ExpRest() { el.addElement(e2); } )*
    | {}
    )
    { return el; }
}

Exp ExpRest() :
{ Exp e; }
{
    "," e = Exp()
    { return e; }
}

// To be able to extract the identifier value
Identifier Identifier() :
{ Token i; }
{
    i = <IDENTIFIER>
    { return new Identifier(i.toString()); }
}

// To be able to extract the int value
IntegerLiteral IntegerLiteral() :
{ Token il; }
{
    il = <INTEGER_LITERAL>
    { return new IntegerLiteral(Integer.parseInt(il.toString())); }
}
